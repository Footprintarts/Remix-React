REMIX TUTORIAL

00. INITIAL SETUP
Let's do this together, lets get started

first you need to have nodeJs installed in your machine,if not , (while showing the Node js site)head over to node js website and download this latest version  then install it and we're good to go

01. REMIX SETUP

So the documentation says: "We'll be building a small, but feature-rich app that lets you keep track of your contacts. "

This is basically an App that is meant to help you save and update your contacts in some other than your phone. anyway it will help us learn the fundamentals of Remix, no database involved here just simulations to keep us focused on REMIX, so lets get started.

Etc: Basic template create> cd > npm run dev


02. THE ROOT ROUTE

the "Root Route". It's the first component in the UI that renders, so it typically contains the global layout for the page.

Right now Looks Ugly so let's add styles in the next section

03. ADDING STYLES WITH LINKS

Still In The Root route

do all that and boom, we are doing great let's keep moving on

04. CONTACT ROUTE UI

- Let's create the routes directory file name MUST be routes this is a special name for route to work in Remix then create a file : Very simple, simplest compared to normal react router

- In the Remix route file convention, . will create a / in the URL and $ makes a segment dynamic. We just created a route that will match URLs that look like this:
	- /contact/ 123
	-/contacts/ abc
	-/contacts/ anystuff

Now if we click one of the links or visit /contacts/1 we get ... nothing new?

05. NESTED ROUTES AND OUTLETS

- Since Remix is built on top of React Router, it supports nested routing. In order for child routes to render inside of parent layouts, we need to render an Outlet in the parent. Let's fix it, open up app/root.tsx and render an outlet inside.

- so in the root directory...

- Now the child route should be rendering through the outlet.

06. CLIENT SIDE ROUTING

- You may or may not have noticed, but when we click the links in the sidebar, the browser is doing a full document request for the next URL instead of client side routing.

Client side routing allows our app to update the URL without requesting another document from the server. Instead, the app can immediately render new UI. 

(Show Network Tab in Dev Tools)

Let's make it happen with <Link>.

ðŸ‘‰ Change the sidebar <a href> to <Link to> in the root directory


07 LOADING DATA:

- So far so good we're doing great, now our app is EMPTY it has no any data to work with so lets see how we can load some data into our remix app

Remix has data conventions to get data into your route components easily.

There are two APIs we'll be using to load data, loader and useLoaderData. First we'll create and export a loader function in the root route and then render the data.

ðŸ‘‰ Export a loader function from app/root.tsx and render the data

That's it! Remix will now automatically keep that data in sync with your UI. The sidebar should now look like this:

08 TYPE INFERENCE

You may have noticed TypeScript complaining about the contact type inside the map. We can add a quick annotation to get type inference about our data with <typeof loader> just after the name


09 URL PARAMS IN LOADERS

Remember the $contactId part of the file name at app/routes/contacts.$contactId.tsx? These dynamic segments will match dynamic (changing) values in that position of the URL. We call these values in the URL "URL Params", or just "params" for short.

These params are passed to the loader with keys that match the dynamic segment. For example, our segment is named $contactId so the value will be passed as params.contactId.

These params are most often used to find a record by ID. Let's try it out.

ðŸ‘‰ Add a loader function to the contact page and access data with useLoaderData

10. DATA MUTATIONS

Without client side routing, the browser will serialize the form's data automatically and send it to the server as the request body for POST, and as URLSearchParams for GET. Remix does the same thing, except instead of sending the request to the server, it uses client side routing and sends it to the route's action function.

We can test this out by clicking the "New" button in our app.

Remix sends a 405 because there is no code on the server to handle this form navigation.

11. CREATING CONTACTS

Remix sends a 405 because there is no code on the server to handle this form navigation.

ðŸ‘‰ Export an action function from app/root.tsx



12. UPDATING DATA

Let's add a way to fill the information for our new record.

Just like creating data, you update data with <Form>. Let's make a new route at app/routes/contacts.$contactId_.edit.tsx.

ðŸ‘‰ Create the edit component

- In Remix we create a component and route at the same time , if in the routes folder

Note the weird _ in $contactId_. By default, routes will automatically nest inside routes with the same prefixed name. Adding a trailing _ tells the route to not nest inside app/routes/contacts.$contactId.tsx.

13. UPDATING CONTACT WITH FORM DATA

The edit route we just created already renders a form. All we need to do is add the action function. Remix will serialize the form, POST it with fetch, and automatically revalidate all the data.

ðŸ‘‰ Add an action function to the edit route


14. MUTATION DISCUSSION

- Open up contacts.$contactId_.edit.tsx and look at the form elements. Notice how they each have a name:

Open up contacts.$contactId_.edit.tsx and look at the form elements. Notice how they each have a name:

Since we have a handful of form fields, we used Object.fromEntries to collect them all into an object, which is exactly what our updateContact function wants.

Aside from the action function, none of these APIs we're discussing are provided by Remix: request, request.formData, Object.fromEntries are all provided by the web platform.

After we finished the action, note the redirect at the end:

action and loader functions can both return a Response (makes sense, since they received a Request!). The redirect helper just makes it easier to return a Response that tells the app to change locations.


15 REDIRECTING NEW 



16. ACTIVE LINK STYLING.

Now that we have a bunch of records, it's not clear which one we're looking at in the sidebar. We can use NavLink to fix this.

ðŸ‘‰ Replace <Link> with <NavLink> in the sidebar


Note that we are passing a function to className. When the user is at the URL that matches <NavLink to>, then isActive will be true. When it's about to be active (the data is still loading) then isPending will be true. This allows us to easily indicate where the user is and also provide immediate feedback when links are clicked but data needs to be loaded.


17. GLOBAL PENDING

As the user navigates the app, Remix will leave the old page up as data is loading for the next page. You may have noticed the app feels a little unresponsive as you click between the list. Let's provide the user with some feedback so the app doesn't feel unresponsive.

Remix is managing all the state behind the scenes and reveals the pieces you need to build dynamic web apps. In this case, we'll use the useNavigation hook.

ðŸ‘‰ Use useNavigation to add global pending UI

useNavigation returns the current navigation state: it can be one of "idle", "loading" or "submitting".

In our case, we add a "loading" class to the main part of the app if we're not idle. The CSS then adds a nice fade after a short delay (to avoid flickering the UI for fast loads). You could do anything you want though, like show a spinner or loading bar across the top.

18. DELETING RECORDS

If we review code in the contact route, we can find the delete button looks like this:

Note the action points to "destroy". Like <Link to>, <Form action> can take a relative value. Since the form is rendered in contacts.$contactId.tsx, then a relative action with destroy will submit the form to contacts.$contactId.destroy when clicked.

At this point you should know everything you need to know to make the delete button work. Maybe give it a shot before moving on? You'll need:

A new route
An action at that route
deleteContact from app/data.ts
redirect to somewhere after
ðŸ‘‰ Create the "destroy" route module



19. INDEX ROUTES

When we load up the app, you'll notice a big blank page on the right side of our list.

Create an index route for the root route
Feel free to copy/paste, nothing special here.

20. CANCEL BUTTON

On the edit page we've got a cancel button that doesn't do anything yet. We'd like it to do the same thing as the browser's back button.

We'll need a click handler on the button as well as useNavigate.

ðŸ‘‰ Add the cancel button click handler with useNavigate

A <button type="button">, while seemingly redundant, is the HTML way of preventing a button from submitting its form.

Two more features to go. We're on the home stretch!


21. URLSearch PARAMS and GET Submission



22. SYNCHRONIZING URLS TO FORM STATE


The input field will show the query if you refresh the page after a search now.


23. SUBMITT ON CHANGE

As you type, the form is automatically submitted now!

Note the argument to submit. The submit function will serialize and submit any form you pass to it. We're passing in event.currentTarget. The currentTarget is the DOM node the event is attached to (the form).

24. ADDING SEARCH SPINNER

In a production app, it's likely this search will be looking for records in a database that is too large to send all at once and filter client side. That's why this demo has some faked network latency.

Without any loading indicator, the search feels kinda sluggish. Even if we could make our database faster, we'll always have the user's network latency in the way and out of our control.

For a better user experience, let's add some immediate UI feedback for the search. We'll use useNavigation again.

ðŸ‘‰ Add a variable to know if we're searching


25. MANAGING HISTORY STACK



26. FORMS without Navigation

UseFetcher
So far all of our forms have changed the URL. While these user flows are common, it's equally common to want to submit a form without causing a navigation.

For these cases, we have useFetcher. It allows us to communicate with actions and loaders without causing a navigation.

The â˜… button on the contact page makes sense for this. We aren't creating or deleting a new record, and we don't want to change pages. We simply want to change the data on the page we're looking at.

ðŸ‘‰ Change the <Favorite> form to a fetcher form

This form will no longer cause a navigation, but simply fetch to the action. Speaking of which ... this won't work until we create the action.



27. Optimistic UI

To give the user some feedback, we could put the star into a loading state with fetcher.state (a lot like navigation.state from before), but we can do something even better this time. We can use a strategy called "Optimistic UI".

The fetcher knows the FormData being submitted to the action, so it's available to you on fetcher.formData. We'll use that to immediately update the star's state, even though the network hasn't finished. If the update eventually fails, the UI will revert to the real data.
























































































































































































